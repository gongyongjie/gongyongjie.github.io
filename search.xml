<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL数据库</title>
      <link href="/2023/06/06/mysql-shu-ju-ku/"/>
      <url>/2023/06/06/mysql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>是指采用了关系模型来组织数据的数据库。 简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。Oracle，MySQL，SQL Server等</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>不规定基于SQL实现，更多是指NoSQL数据库，如：1.基于键值对（Key-Value）：如 memcached、redis；2.基于文档型：如 mongodb；3.基于列族：如 hbase；4.基于图型：如 neo4j</p><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230606142107999.png" alt="区别"></p><h3 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h3><ul><li>OLTP，全称On-Line transaction processing，即翻译为<strong>联机事务处理</strong>。主要对数据库<strong>增删改查</strong>。<br>OLTP 主要用来记录某类业务事件的发生；数据会以增删改的方式在数据库中进行数据的更新处理操作，要求实时性高、稳定性强、确保数据及时更新成功。</li><li>OLAP，全称On-Line Analytical Processing，即翻译为<strong>联机分析处理</strong>。主要对<strong>数据库查询</strong>。<br>当数据积累到一定的程度，需要对过去发生的事情做一个总结分析时，就需要把过去一段时间内产生的数据拿出来进行统计分析，从中获取我们想要的信息，为公司做决策提供支持，这时候就是在做OLAP了。</li><li>SQL，全称(Structured Query Language)，简称 SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。SQL 是关系数据库系统的标准语言。</li></ul><h2 id="二、MySQL体系架构"><a href="#二、MySQL体系架构" class="headerlink" title="二、MySQL体系架构"></a>二、MySQL体系架构</h2><p>从整体上看，整个MySQL数据库的服务端可以分为四层：<strong>Server层</strong>和 <strong>存储引擎层</strong></p><p><img src="/2023/06/06/mysql-shu-ju-ku/02f2857f100647e8b7b665f682b63bda.png" alt="MySQL体系架构"></p><h3 id="Server层"><a href="#Server层" class="headerlink" title="Server层"></a>Server层</h3><p><strong>客户端连接器：</strong>向外提供的交租组件。连接工具：Navicat，DBeaver，DbVisualizer。可以通过<code>show processlist命令</code>查看连接：</p><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230606145748576.png" alt="先登录"></p><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230606145808776.png" alt="连接信息"></p><blockquote><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。在数据库中，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。建立连接的过程通常是比较复杂的，所以尽量使用长连接 。</p><p>全部使用长连接，有些时候MySQL占用内存涨得特别快。解决方法：通过执行函数<code>mysql_reset_connection()</code>来重新初始化连接资源。这个过程不需要重连和重新做权限验证，而是会将连接恢复到刚刚创建完时的状态。</p></blockquote><p><strong>连接池组件：</strong>管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求<br><strong>管理服务和工具组件：</strong>系统管理和控制工具，例如备份恢复、MySQL 复制、集群等<br><strong>SQL接口组：</strong>接收用户的SQL命令，解析生成相应对象；DML，DDL，存储过程，视图，触发器等，然后返回给用户<br><strong>查询分析器组件：</strong>在执行SQL语句前，分析出语句要干嘛<br><strong>查询优化器组件：</strong>SQL语句执行前，使用查询优化器进行优化，选择执行效率最优的方案，如：索引，多表联查等等<br><strong>缓冲组件：</strong>是一块内存区域，查询缓存中有命中的结果，查询语句就直接去查询缓存中取数据；<strong>MySQL8.0后删除了</strong></p><p><strong>执行一条select语句的过程：</strong></p><ol><li>连接器：主要作用是建立连接、管理连接及校验用户信息</li><li>查询缓冲：查询缓冲是以key-value的方式存储，key就是查询语句，value就是查询语句的查询结果集；如果命中直接返回。注意：MySQL8.0已经删除了查询缓冲</li><li>分析器：识别出里面的字符串分别是什么，代表什么，语法分析</li><li>优化器：指定执行计划，选择查询成本最小的计划</li><li>执行器：根据执行计划，从存储引擎获取数据，并返回客户端</li><li><img src="/2023/06/06/mysql-shu-ju-ku/640-16861035968752.png" alt="执行一条select语句的过程"></li></ol><h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p>MySQL5.5之前的版本默认存储引擎是MyISAM；5.5之后是InnoDB。Innodb的单表限制基本上也在64TB左右。</p><ul><li>InnoDB：支持事务、索引、锁，使用InnoDB存储表时，将<strong>表的定义</strong>和<strong>数据索引</strong>等信息分别存储在 <strong>.frm 文件和 .ibd</strong> 文件中。</li><li>MyISam：不支持事务、不支持外键，支持索引，其优势是访问的速度快。MyISAM的表在磁盘上会生成3个不同类型的文件，文件名和表名相同，分别为：.frm (存储表定义)；.MYD(MYData , 存储数据)；.MYI(MYIndex , 存储索引)。</li><li>Memory：Memory存储引擎将表的数据存放在内存中。每个MEMORY表对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，数据文件存储在内存中，有利于数据的快速处理，提高整个表的读写效率。MEMORY类型的表访问非常地快，默认使用HASH索引，其速度比使用B+Tree索引要快，但是<strong>服务一旦关闭，表中的数据就会丢失</strong>。</li></ul><p><strong>执行一条update语句，存储引擎的执行图：</strong></p><p><img src="/2023/06/06/mysql-shu-ju-ku/640-16861039149264.png" alt="执行图"></p><blockquote><p>执行update的时候，每条 SQL 语句，都会对应：加载磁盘数据到Buffer Pool里、写undo日志、写redo log buffer几个步骤。但是当提交事务的时候，一定会把redo log日志刷入磁盘，binlog日志刷入磁盘，完成redo log文件中的事务commit标记。然后在某一时刻，由后台的IO线程随机地把Buffer Pool里的脏数据刷到磁盘里。</p></blockquote><h3 id="InnoDB的存储结构"><a href="#InnoDB的存储结构" class="headerlink" title="InnoDB的存储结构"></a>InnoDB的存储结构</h3><p>逻辑存储结构：所有创建的表都放在一个表空间里，表空间由segment段、extend区、page页组成，其中page页是物理存储磁盘管理的最小单位(默认大小为16K)。</p><ul><li>在物理层面，表空间其实就是磁盘上的一些.ibd 数据文件</li><li>段：数据段，索引段，回滚段等。</li><li>区：对应着连续的 64 个数据页，每个数据页是 16KB，所以一个数据区是固定是1MB。一个InnoDB存储引擎最多申请4个区，保证数据的顺序性能，即：<strong>一组数据区域</strong>。</li></ul><p><img src="/2023/06/06/mysql-shu-ju-ku/640.png" alt="逻辑存储结构"></p><blockquote><p>如果启用了innodb_file_per_table参数，每张表的表空间只存放数据、索引和插入缓冲的数据；其他的数据如撤销信息、系统事务信息、double write buffer等还是存放在共享表空间中</p></blockquote><h3 id="InnoDB的内存结构"><a href="#InnoDB的内存结构" class="headerlink" title="InnoDB的内存结构"></a>InnoDB的内存结构</h3><p>页是InnoDB磁盘的最小单位，数据都存在页中，对应到内存中就是一个一个的Buffer；Buffer Pool，它本质上就是一片内存，里面存储了 MySQL 的表数据。并且这片内存是可配置的，因为它不可能无限大，<strong>默认是 128MB</strong>。 MySQL 操作数据是以页为单位的，假设我们要更新一行数据，<strong>此时 MySQL 会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页加载到Buffer Pool</strong>。</p><p>每一个缓存页都有一个描述信息，这个描述信息就是用来描述缓存页的。比如：对应的数据页所属的表空间、页号，以及<strong>当前缓存页在 Buffer Pool 中的地址</strong>以及别的一些信息。也是个数据块，占了大概 800 字节</p><p>Buffer三种状态以及管理状态的三种双向链表：</p><ul><li><strong>freeBuffer</strong>：未被使用；<strong>free list</strong>：记录空闲的Buffer</li><li><strong>cleanBuffer</strong>：和磁盘中页的数据一致的Buffer；<strong>lru list</strong>：记录最近最少使用的Buffer</li><li><strong>dirtyBuffer</strong>：和磁盘中页的数据不同的Buffer；<strong>flush list</strong>：记录脏Buffer，方便刷新到磁盘</li></ul><h4 id="改进的LRU：冷热数据分离"><a href="#改进的LRU：冷热数据分离" class="headerlink" title="改进的LRU：冷热数据分离"></a>改进的LRU：冷热数据分离</h4><p>如果只是简单的LRU，<strong>预读机制、全表扫描机制</strong>，都会将大量不怎么访问的数据页加载到缓存页中，然后LRU链表的前面可能全部都是未来不怎么访问的数据页（的描述数据块）。而真正被频繁访问的缓存页，其描述数据块都在 LRU 链表的尾部了，然后缓存页淘汰的时候，就会将那些真正被频繁访问的缓存页淘汰掉。</p><p>真正的 LRU 链表会被拆成两部分，一部分是冷数据，一部分是热数据，冷热比例由参数 innodb_old_blocks_pct 控制，默认是 37，也就是冷数据占比 37%。所以这个 LRU 链表应该长下面这样：</p><p><img src="/2023/06/06/mysql-shu-ju-ku/640-16861086748296.png" alt="LRU链表"></p><blockquote><p>首先数据页在加载到 Buffer Pool 的时候，会使用冷区域链表的头部的缓存页，因为加载数据页就意味着要访问，但如果访问完这一次之后就再也不访问了怎么办？所以 MySQL 有一个参数 innodb_old_blocks_time，默认是 1000 毫秒，如果 1 秒钟之后又访问了这个缓存页，那么它才会被移动到热区域链表的头部。</p></blockquote><h4 id="刷新缓存页到磁盘"><a href="#刷新缓存页到磁盘" class="headerlink" title="刷新缓存页到磁盘"></a>刷新缓存页到磁盘</h4><ol><li>完全检查点：数据库实例关闭时，把所有脏页都写入磁盘</li><li>模糊检查点：<ul><li>每个一段时间刷新少量脏页：<code>innodb_io_capacity</code>控制脏页数量</li><li>当LRU中空闲页不足的时候</li><li>当重做日志redo log不够用时候</li><li>脏页数量达到了一定的比例，默认是90%</li></ul></li></ol><h2 id="三、MySQL索引"><a href="#三、MySQL索引" class="headerlink" title="三、MySQL索引"></a>三、MySQL索引</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>这里的 B 是 Balance（平衡）的缩写。它是一种多路的平衡搜索树</li><li>它跟普通的平衡二叉树的不同是，B树的每个节点可以存储多个数据，而且每个节点不止有两个子节点，最多可以有上千个子节点</li><li>B树中每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，最好的情况是O(1)</li><li>一般一棵 B 树的高度在 3 层左右，3 层就可满足百万级别的数据量</li></ul><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230607141147560.png" alt="B树"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li>叶子节点保存了完整的索引和数据，而非叶子节点只保存索引值，不存储数据<ul><li>非叶子节点只保存索引，存储的索引更多，一次加载到内存的索引也更多，即：IO读写次数也就降低了</li><li>查询时间固定为log(n)，即：O(logn)的复杂度</li></ul></li><li>叶子节点的数据都是使用链表连接起来的，并且有序<ul><li>他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读机制就会提前把这些数据都读进内存，使得范围查询和排序都很快，<strong>减少了磁盘 IO 的次数</strong></li><li>叶子节点都是排序存储的，增加了区间访问性，提高了范围查询</li></ul></li></ul><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230607141645135.png" alt="B+树"></p><h3 id="MySQL中的B-树"><a href="#MySQL中的B-树" class="headerlink" title="MySQL中的B+树"></a>MySQL中的B+树</h3><p>索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的渐进复杂度。换句话说，<strong>索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数</strong>。</p><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230607142844889.png" alt="MySQL的B+树"></p><blockquote><p>MySQL中的B+树中每个节点是一页，默认大小是16K。顶端的索引页里面的指针，指向下一层索引页；第二层索引页里面的指针，则指向数据页。数据页之间组成一个双向链表，每个数据页里面保存了数据行，数据行之间组成单向链表。</p></blockquote><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引就是一棵 B+ 树组成的数据结构，一张表如果有多个索引，那么就有多棵 B+ 树。而数据页（具体数据）位于聚簇索引（基于主键组织）的叶子节点上，其它的二级索引的叶子结点只保存了主键值。</p><p><strong>聚簇索引：</strong>是基于主键组织的索引，数据页和索引页存储在一起。聚簇索引对应的B+树，其叶子节点就是数据页，数据页里面存储的是完整的行数据，非叶子节点存储的则是主键和指针。</p><p><strong>非聚簇索引(二级索引)：</strong>在非主键字段上建立的索引。比如基于name字段建索引，同样会生成一棵 B+ 树，其规则和聚簇索引一模一样；但不同的是，<strong>聚簇索引的叶子节点存储了完整的数据，而二级索引的叶子节点存储的是相应的主键值</strong>。</p><p><strong>复合索引：</strong>同时给多个字段建索引。比如有一张表，我们基于里面的 name、age、salary 三个字段建立复合索引。</p><p><img src="/2023/06/06/mysql-shu-ju-ku/image-20230607144450314.png" alt="对比图"></p><blockquote><p>比如 select * from t where name &#x3D; ‘marisa’ 这行语句，由于 name 字段建立了索引，那么能快速找到对应的主键值为 3。拿到主键值之后，再根据主键值到聚簇索引里面查找，即可拿到完整的数据，而这个过程就叫做<strong>回表</strong>。</p><p>也就是说，光靠二级索引是拿不到完整数据的，只能拿到主键和作为索引的字段本身。如果想获取完整数据，或者说其它字段的数据，那么还要基于主键再到聚簇索引里面查询一次。而用二级索引拿到的主键值，再去聚簇索引里面查询的这个过程就是回表。</p><p>当然啦，如果我们只获取 name 字段，那么需不需要回表呢？显然此时是不需要的，因为索引就是基于 name 字段建立的，这棵 B+ 树里面包含了 name 字段。但如果想同时获取 name 和 gender 字段，那么就需要回表了。</p></blockquote><h4 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h4><p><strong>等值匹配：</strong><br>where 语句中的字段和索引字段一样，而且是等值匹配，那么百分百会使用到索引。复合索引也是同理，并且即使 where 语句里的字段顺序和复合索引里的字段顺序不一致也没关系，MySQL 会自动优化为复合索引的字段顺序去找。</p><p><strong>最左侧列匹配：</strong><br>这个针对的是复合索引，假设索引是 <code>KEY(name, age, addr)</code>，那么不一定非要同时根据这三个字段来查，用一个或两个也是可以的。但查询的时候，<strong>必须要使用最左侧的字段去查</strong>。比如：根据 name 和 age 去查，那么 name 和 age 可以走索引；但根据 name 和 addr 去查，那么只有 name 会走索引，addr 无法走索引；要是根据 age 和 addr 去查，那么这两个字段都无法走索引。当前复合索引有三个字段，那么可以看成是桥头、桥中、桥尾，只能从左往右，如果中间出现了断层，那么断层后面的字段就无法走索引了。</p><p><strong>最左前缀匹配：</strong><br>这个说的是 like 语法，比如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> t <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'sa%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果给 name 字段建了索引，那么此时可以走索引。但如果改成 <code>&#39;%sa&#39;</code> 就走不了索引了，因为不知道最左前缀是什么。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaSE</title>
      <link href="/2023/04/27/javase/"/>
      <url>/2023/04/27/javase/</url>
      
        <content type="html"><![CDATA[<h2 id="步入Java"><a href="#步入Java" class="headerlink" title="步入Java"></a>步入Java</h2><p><img src="/2023/04/27/javase/image-20230414104951532.png" alt="Java代码开发三步骤"></p><h3 id="一、概念JDK，IDE等"><a href="#一、概念JDK，IDE等" class="headerlink" title="一、概念JDK，IDE等"></a>一、概念JDK，IDE等</h3><ul><li>JVM（Java Virtual Machine）：Java虚拟机, 真正运行Java程序的地方。</li><li>核心类库：Java自己写好的程序，给程序员自己的程序调用的。</li><li>JRE（Java Runtime Environment）: Java的运行环境。</li><li>JDK（Java Development Kit）: Java开发工具包（我们配置环境就是下载jdk，不同版本的开发工具包都可以用）</li></ul><p><img src="/2023/04/27/javase/image-20230414105330750.png" alt="JDK的组成"></p><p><strong>Java的跨平台是什么含义，Java如何实现跨平台的？</strong><br>答：一次编译、处处可用。我们的程序只需要开发一次，就可以在各种安装了JVM的系统平台上（Windows，Linux，MacOS）运行</p><p><strong>集成开发环境（ IDE, Integrated Development Environment ）</strong><br>答：把代码编写，编译，执行等多种功能综合到一起的开发工具，可以进行代码智能提示，错误提醒，项目管理等等。常见Java的IDE工具有：Eclipse、MyEclipse、IntelliJ IDEA、Jbuilder、NetBeans等。</p><h3 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h3><p><img src="/2023/04/27/javase/image-20230417111637278.png" alt="基本类型"></p><p><strong>1、类型转换</strong>：自动类型转换，表达式的自动类型转换，强制类型转换</p><p><img src="/2023/04/27/javase/image-20230417145523206.png" alt="image-20230417145523206"></p><p><strong>2、逻辑运算符：</strong></p><table><thead><tr><th>符号</th><th>介绍</th><th>说明</th></tr></thead><tbody><tr><td>&amp;</td><td>逻辑与</td><td>可用于位运算，当左右两边的条件不是布尔型，而是数字时，会进行位运算</td></tr><tr><td>|</td><td>逻辑或</td><td>只要有一个为true、结果就是true</td></tr><tr><td>！</td><td>逻辑非</td><td>你真我假、你假我真。 !true&#x3D;false 、 !false&#x3D; true</td></tr><tr><td>^</td><td>逻辑异或</td><td>如果两个条件都是false或者都是true则结果是false。两个条件不同结果是true</td></tr><tr><td>&amp;&amp;</td><td>短路与</td><td>判断结果与“&amp;”一样。过程是<strong>左边为</strong> <strong>false，右边则不执行</strong></td></tr><tr><td>||</td><td>短路或</td><td>判断结果与“|”一样。过程是<strong>左边为</strong> <strong>true， 右边则不执</strong></td></tr></tbody></table><p><strong>3、参数传递机制：</strong></p><p><img src="/2023/04/27/javase/image-20230418204653205.png" alt="基本类型参数传递"></p><p><img src="/2023/04/27/javase/image-20230418204708216.png" alt="引用类型的参数传递"></p><p><strong>4、方法重载：</strong><br>只要是<strong>同一个类</strong>中，<strong>方法名称相同、形参列表不同（形参个数、类型、顺序，任何一个不同）</strong>，那么他们就是重载的方法，其他都不管！（如：修饰符，返回值类型都无所谓）</p><table><thead><tr><th align="center"><strong>区别</strong></th><th align="center"><strong>方法重写</strong></th><th align="center"><strong>方法重载</strong></th></tr></thead><tbody><tr><td align="center">方法关系</td><td align="center">描述的是 <strong>父类和子类(接口实现)</strong> 的方法关系</td><td align="center">描述的是<strong>同一个类中</strong>多个同名方法的方法关系</td></tr><tr><td align="center">Override 关键字</td><td align="center">需要使用 @Override 关键字修饰</td><td align="center">不需要</td></tr><tr><td align="center">参数类型和参数个数</td><td align="center">不能修改</td><td align="center">必须修改</td></tr><tr><td align="center">返回类型</td><td align="center">只能变小或相同，不能变大</td><td align="center">可修改</td></tr><tr><td align="center">抛出异常</td><td align="center">只能变小或删除，不能抛出新的或者更大的异常</td><td align="center">可修改</td></tr><tr><td align="center">权限控制符</td><td align="center">只能变大，不能变小</td><td align="center">可修改</td></tr></tbody></table><h3 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h3><p>面向对象又称OOP(Object Oriented Programming) 分开来看就是：Object：对象，Oriented： 面向的，Programming：程序设计。</p><p><strong>面向对象的三大特征：</strong>封装，继承，多态。</p><p><img src="/2023/04/27/javase/image-20230420123204270.png" alt="多个对象的内存图"></p><p><strong>构造器：</strong>定义在类中的，可以用于初始化一个类的对象，并返回对象的地址。</p><ul><li>无参数构造器（默认存在的）：初始化对象时，成员变量的数据均采用默认值。</li><li>有参数构造器：在初始化对象的时候，同时可以接收参数为对象进行赋值。</li></ul><p><strong>注意：</strong>一旦定义了有参数构造器，那么无参数构造器就没有了，如果还想用无参数构造器，此时就需要自己手写一个无参数构造器了。</p><p><strong>成员变量和局部变量的区别：</strong></p><table><thead><tr><th align="center">区别</th><th align="center">成员变量</th><th align="center">局部变量</th></tr></thead><tbody><tr><td align="center">类中位置不同</td><td align="center">类中，方法外</td><td align="center">常见于方法中</td></tr><tr><td align="center">初始化值不同</td><td align="center">有默认值,无需初始化</td><td align="center">没有默认值，使用之前需要完成赋值</td></tr><tr><td align="center">内存位置不同</td><td align="center">堆内存</td><td align="center">栈内存</td></tr><tr><td align="center">生命周期不同</td><td align="center">随着对象的创建而存在，随着对象的消失而消失</td><td align="center">随着方法的调用而存在，随着方法的运行结束而消失</td></tr><tr><td align="center">作用域</td><td align="center"></td><td align="center">在所归属的大括号中</td></tr></tbody></table><p><strong>权限修饰符：</strong>有四种作用范围由小到大（<strong>private</strong> -&gt; 缺省 -&gt; <strong>protected</strong> - &gt; public ），最大范围依次是（<strong>同一个类中</strong>，同一包的所有类中，<strong>不同包的子类中</strong>，不同包的所有类中）</p><p><strong>继承：</strong></p><ul><li>子类可以<strong>继承父类的属性和行为</strong>，但是子类不能继承父类的构造器</li><li>子类<strong>可以继承</strong>父类的私有成员变量和私有方法，只是不能直接访问</li><li>子类<strong>不能继承</strong>父类的静态成员变量和静态方法，只是可以共享使用，并非继承</li><li>子类中所有的构造器默认都会先访问父类中无参构造器，再执行自己的构造器（因为子类有可能会使用到父类中的数据），子类构造器的第一行语句默认都是：super()，不写也存在</li></ul><p><strong>多态：</strong></p><p>同类型的对象，执行同一个方法，可以表现为不同的形态。前提：有继承&#x2F;实现关系；有父类引用指向子类对象；有方法重写。</p><p>多态中成员访问特点：</p><ul><li>方法调用：编译看左边，运行看右边。</li><li>变量调用：编译看左边，运行也看左边。（注意）</li></ul><h4 id="1-static关键字"><a href="#1-static关键字" class="headerlink" title="1.static关键字"></a>1.static关键字</h4><p><strong>静态成员变量</strong>：有static修饰，属于类、加载一次，内存中只有一份。</p><p><strong>静态成员方法：</strong>有static修饰，归属于类，建议用类名访问。</p><p><strong>注意：</strong></p><ul><li>静态方法只能访问静态成员变量和静态方法，不可以直接访问实例成员变量和实例方法。</li><li>实例方法可以访问静态成员变量和静态方法，也可以访问实例成员变量。</li><li>静态方法中是不可以出现this关键字的。</li></ul><p><strong>静态代码块:</strong><br>格式：static{}<br>特点：需要通过static关键字修饰，随着<strong>类的加载而加载</strong>，并且自动触发、只执行一次。一般在类加载的时候做一些静态数据初始化的操作，以便后续使用。</p><p><strong>构造代码块（了解，见的少）：</strong><br>格式：{}<br>特点：每次创建对象，调用构造器执行时，都会执行该代码块中的代码，并且在构造器执行前执行，一般用来初始化实例资源。</p><p><img src="/2023/04/27/javase/image-20230424150009288.png" alt="静态成员变量内存分析"></p><p><img src="/2023/04/27/javase/image-20230424151034684.png" alt="静态成员方法内存分析"></p><h4 id="2-final关键字"><a href="#2-final关键字" class="headerlink" title="2.final关键字"></a>2.final关键字</h4><ul><li>修饰类：表明该类是最终类，<strong>不能被继承</strong>。</li><li>修饰方法：表明该方法是最终方法，<strong>不能被重写</strong>。</li><li>修饰变量：<ul><li>final修饰的变量是基本类型：那么变量存储的<strong>数据值不能发生改变</strong>。</li><li>final修饰的变量是引用类型：那么变量存储的<strong>地址值不能发生改变，但是地址指向的对象内容是可以发生变化的</strong>。</li></ul></li><li>常量：public static final修饰的成员变量。在编译阶段会进行“宏替换”：把使用常量的地方全部替换成真实的字面量。常用来作为<strong>信息标志和分类：UP，DOWN，LEFT，RIGHT</strong></li></ul><h4 id="3-abstract抽象"><a href="#3-abstract抽象" class="headerlink" title="3.abstract抽象"></a>3.abstract抽象</h4><p><strong>使用抽象类是为了代码的复用</strong>：提供公共的实现代码，抽象出有重复部分。</p><ul><li>abstract可以修饰类、成员方法，类就是抽象类，方法就是抽象方法。抽象方法只有方法名，例如：<code>absract void brew();</code>，不能声明方法体</li><li>一个类中如果定义了抽象方法，这个类必须声明成抽象类，否则报错</li><li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>应用：模板方法设计模式</li></ul><h4 id="4-interface接口"><a href="#4-interface接口" class="headerlink" title="4.interface接口"></a>4.interface接口</h4><p><strong>使用接口的动机是为了实现多态性</strong>：体现的是一种规范（约束）思想，注重代码的扩展性和可维护性。</p><p>JDK8之前：</p><ul><li>接口中只能是<strong>抽象方法和常量</strong>，接口不能实例化，接口中的成员都是<strong>public修饰的</strong></li><li>一个类可以<strong>实现多个接口</strong>，一个接口可以同时<strong>继承多个接口</strong></li></ul><p>JDK8之后<strong>新增的</strong>方法：</p><ul><li><p>默认方法（实例方法）：default修饰，只能实现类的对象进行调用</p></li><li><p>静态方法：static修饰，只能用当前接口类名调用</p></li><li><p>私有方法：private修饰，JDK9开始才有的，只能在接口内部被其他方法调用</p></li><li><p>他们都会<strong>默认被public修饰</strong></p></li></ul><h4 id="5-enum枚举"><a href="#5-enum枚举" class="headerlink" title="5.enum枚举"></a>5.enum枚举</h4><h4 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h4><p>匿名内部类是一个没有名字的内部类，同时也代表一个对象，它的类型是当前new的那个类型的子类类型。<strong>最终目的为了简化代码编写</strong></p><h3 id="四、字符串类"><a href="#四、字符串类" class="headerlink" title="四、字符串类"></a>四、字符串类</h3><p>String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。以“XXX”方式给出的字符串对象，在<strong>字符串常量池</strong>中存储。</p><ul><li>String变量每次的修改其实都是产生并指向了新的字符串对象，原来的字符串对象都是没有改变的，所以称不可变字符串。</li></ul><p><img src="/2023/04/27/javase/image-20230420171202573.png" alt="不可变字符串类型"></p><p><img src="/2023/04/27/javase/image-20230420165900264.png" alt="字符串常量池"></p><p><img src="/2023/04/27/javase/image-20230420165741993.png" alt="new创建的字符串对象"></p><p><img src="/2023/04/27/javase/image-20230428151134241.png" alt="String类拼接的内存图"></p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测评价指标</title>
      <link href="/2023/03/16/mu-biao-jian-ce-ping-jie-zhi-biao/"/>
      <url>/2023/03/16/mu-biao-jian-ce-ping-jie-zhi-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h2><ul><li>Precision准确率：TP &#x2F; (TP + FP)，评判找的准不准。</li><li>Recall召回率:：TP &#x2F; (TP + FN)，评判找的全不全。</li></ul><p>目标检测一般使用 mAP 作为评价指标，涉及到下面几个定义：</p><h3 id="1-mAP"><a href="#1-mAP" class="headerlink" title="1.mAP"></a>1.mAP</h3><ul><li>PR曲线: Precision-Recall曲线，Precision 纵轴，Recall 横轴</li><li>AP: PR曲线下面积</li><li>mAP: mean Average Precision, 即各类别AP的平均值</li></ul><img src="/2023/03/16/mu-biao-jian-ce-ping-jie-zhi-biao/344a5a50c73c499fb925af715a668936.png" alt="344a5a50c73c499fb925af715a668936" style="zoom:50%;"><ul><li>$AP_{50}$：loU阈值为0.5时的AP测量值</li><li>$AP_{75}$：loU阈值为0.75时的测量值</li><li>$AP_{S}$：像素面积小于$32^2$的目标框的AP测量值</li><li>$AP_{M}$：像素面积在$32^2$-$96^2$ 之间目标框的AP测量值</li><li>$AP_{L}$：像素面积大于$96^2$的目标框的AP测量值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习环境搭搭建_pytorch-gpu</title>
      <link href="/2023/03/15/shen-du-xue-xi-huan-jing-da-da-jian-pytorch-gpu/"/>
      <url>/2023/03/15/shen-du-xue-xi-huan-jing-da-da-jian-pytorch-gpu/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/weixin_44791964/article/details/106037141"> 深度学习环境配置2——windows下的torch&#x3D;1.2.0环境配置_torch1.2_Bubbliiiing的博客-CSDN博客</a></p></blockquote><h2 id="1-创建虚拟的Python环境"><a href="#1-创建虚拟的Python环境" class="headerlink" title="1.创建虚拟的Python环境"></a>1.创建虚拟的Python环境</h2><ol><li>列出当前存在的环境</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">env</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2023/03/15/shen-du-xue-xi-huan-jing-da-da-jian-pytorch-gpu/image-20211227164215824.png" alt="image-20211227164215824"></p><ol start="2"><li>创建虚拟环境</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create <span class="token parameter variable">-n</span> env_name <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.7</span><span class="token comment"># 同时安装必要的包</span>conda create <span class="token parameter variable">-n</span> env_name numpy matplotlib <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.7</span><span class="token comment"># 镜像源</span>pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt <span class="token parameter variable">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple/pip <span class="token function">install</span> <span class="token parameter variable">-i</span> https://pypi.tuna.tsinghua.edu.cn/simple XXXX<span class="token comment"># 默认安装路径：Anaconda安装目录envs文件下找到。可以指定安装路径</span>conda create <span class="token parameter variable">--prefix</span><span class="token operator">=</span><span class="token string">"D:\Anaconda<span class="token entity" title="\e">\e</span>nvs<span class="token entity" title="\e">\e</span>nv_name"</span>  <span class="token assign-left variable">python</span><span class="token operator">=</span><span class="token number">3.7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>激活虚拟环境：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Linux: </span><span class="token builtin class-name">source</span> activate env_name<span class="token punctuation">(</span>虚拟环境名称<span class="token punctuation">)</span><span class="token comment"># Windows: </span>activate env_name<span class="token punctuation">(</span>虚拟环境名称<span class="token punctuation">)</span><span class="token comment">#  此时使用python --version可以检查当前python版本（即虚拟环境的python版本）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>退出虚拟环境：</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Linux: </span><span class="token builtin class-name">source</span> deactivate<span class="token comment"># Windows:</span>conda deactivate<span class="token comment"># 也可以使用activate root切回root环境</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>删除虚拟环境：使用命令， 即可删除。</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda remove <span class="token parameter variable">-n</span> env_name <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>conda常用命令</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda list：查看安装了哪些包。conda <span class="token function">install</span> <span class="token parameter variable">-n</span> my_py_env package_name：安装包conda uninstall <span class="token parameter variable">-n</span> my_py_env package_name：卸载包conda remove <span class="token parameter variable">--name</span> <span class="token variable">$env_name</span> <span class="token variable">$package_name</span>：删除虚拟环境中的包<span class="token punctuation">(</span>conda remove package_name<span class="token punctuation">)</span>conda <span class="token function">install</span> package_name：安装包conda <span class="token function">env</span> list 或 conda info -e：查看当前存在哪些虚拟环境conda update conda：检查更新当前conda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2023/03/15/shen-du-xue-xi-huan-jing-da-da-jian-pytorch-gpu/image-20230315145951666.png" alt="image-20230315145951666"></p><h2 id="2-显卡"><a href="#2-显卡" class="headerlink" title="2.显卡"></a>2.显卡</h2><p><strong>CUDA(Cudatoolkit)</strong> ：运算平台，可以理解为一个内核是GPU的工作台（工作平台）</p><p><strong>Cudnn</strong>：为深度学习计算设计的软件库。可以理解为工作台上的很多工具</p><p>python，pytorch，torchvision，torchaudio，cudatoolkit要相互匹配</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二个文章</title>
      <link href="/2023/03/06/di-er-ge-wen-zhang/"/>
      <url>/2023/03/06/di-er-ge-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>HashMap源码解析:</p><h4 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h4><blockquote><p>引自CSDN博客：<a href="https://blog.csdn.net/carson_ho/article/details/79373026">https://blog.csdn.net/carson_ho/article/details/79373026</a></p></blockquote><ol><li><code>HashMap</code>的本质 &#x3D; 1个存储<code>Entry</code>类对象的数组 + 多个单链表</li><li><code>Entry</code>对象本质 &#x3D; 1个映射（键 - 值对），属性包括：键（<code>key</code>）、值（<code>value</code>）、 下1节点( <code>next</code>) &#x3D; 单链表的指针 &#x3D; 也是一个<code>Entry</code>对象，<code>hash</code>值</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * Entry类实现了Map.Entry接口 * 即 实现了getKey()、getValue()、equals(Object o)和hashCode()等方法**/</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>  <span class="token comment">// 键</span>    <span class="token class-name">V</span> value<span class="token punctuation">;</span>  <span class="token comment">// 值</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个节点 ，也是一个Entry对象，从而形成解决hash冲突的单链表</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>  <span class="token comment">// hash值</span>      <span class="token comment">/**      * 构造方法，创建一个Entry      * 参数：哈希值h，键值k，值v、下一个节点n      */</span>      <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">K</span> k<span class="token punctuation">,</span> <span class="token class-name">V</span> v<span class="token punctuation">,</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          value <span class="token operator">=</span> v<span class="token punctuation">;</span>          next <span class="token operator">=</span> n<span class="token punctuation">;</span>          key <span class="token operator">=</span> k<span class="token punctuation">;</span>          hash <span class="token operator">=</span> h<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token comment">// 返回 与 此项 对应的键</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">K</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> key<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 返回 与 此项 对应的值</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> value<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">V</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">V</span> oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>          value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>          <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>         <span class="token comment">/**      * equals（）     * 作用：判断2个Entry是否相等，必须key和value都相等，才返回true       */</span>       <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>          <span class="token class-name">Object</span> k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">Object</span> k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token class-name">Object</span> v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">Object</span> v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>          <span class="token comment">/**      * hashCode（）      */</span>     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token comment">/**      * 当向HashMap中添加元素时，即调用put(k,v)时，      * 对已经在HashMap中k位置进行v的覆盖时，会调用此方法      * 此处没做任何处理      */</span>      <span class="token keyword">void</span> <span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span>        <span class="token comment">/**      * 当从HashMap中删除了一个Entry时，会调用该函数      * 此处没做任何处理      */</span>      <span class="token keyword">void</span> <span class="token function">recordRemoval</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当new HashMap对象的时候，调用构造函数，给属性赋值。容量就是16，扩容阈值 &#x3D; 初始容量也是16。</p><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210204143515239.png" alt="image-20210204143515239"></p><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210204153723982.png" alt="image-20210204153723982"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   <span class="token comment">/**     * 源码分析：主要分析： HashMap的put函数     */</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span>（分析<span class="token number">1</span>）<span class="token comment">// 1. 若 哈希表未初始化（即 table为空) 则使用构造函数时设置的阈值(即初始容量) 初始化数组table  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token constant">EMPTY_TABLE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>          <span class="token comment">// 2. 判断key是否为空值null</span>（分析<span class="token number">2</span>）<span class="token comment">// 2.1 若key == null，则将该键-值存放到数组table中的第1个位置，即table[0]</span>        <span class="token comment">// （本质：key = Null时，hash值 = 0，故存放到table[0]中）</span>        <span class="token comment">// 该位置永远只有1个value，新传进来的value会覆盖旧的value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>（分析<span class="token number">3</span>） <span class="token comment">// 2.2 若 key ≠ null，则计算存放数组 table 中的位置（下标、索引）</span>        <span class="token comment">// a. 根据键值key计算hash值</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3. 判断该key对应的值是否已存在（通过遍历,以该数组元素为头结点的链表逐个判断）</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Object</span> k<span class="token punctuation">;</span>（分析<span class="token number">4</span>）<span class="token comment">// 3.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token comment">//并返回旧的value</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>（分析<span class="token number">5</span>）<span class="token comment">// 3.2 若 该key不存在，则将“key-value”添加到table中</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析1：初始化哈希表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">（分析<span class="token number">1</span>）<span class="token comment">// 1. 若 哈希表未初始化（即 table为空) 则使用构造函数时设置的阈值(即初始容量) 初始化数组table  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> <span class="token constant">EMPTY_TABLE</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 1. 将传入的容量大小转化为：>传入容量大小的最小的2的次幂</span>    <span class="token comment">// 即如果传入的是容量大小是19，那么转化后，初始化容量大小为32（即2的5次幂）</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-></span><span class="token operator">></span>分析<span class="token number">1</span>       <span class="token comment">// 2. 重新计算阈值 threshold = 容量 * 加载因子  </span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 3. 使用计算后的初始容量（已经是2的次幂） 初始化数组table（作为数组长度）</span>    <span class="token comment">// 即 哈希表的容量大小 = 数组大小（长度）</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//用该容量初始化table  </span>    <span class="token function">initHashSeedAsNeeded</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>      <span class="token comment">/**     * 分析1：roundUpToPowerOf2(toSize)     * 作用：将传入的容量大小转化为：>传入容量大小的最小的2的幂     * 特别注意：容量大小必须为2的幂，因为在后面计算下标的时候(table.length - 1) &amp; hash，二进制最后几位刚好为1     */</span>     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">//若 容量超过了最大值，初始化容量设置为最大值 ；否则，设置为：>传入容量大小的最小的2的次幂</span>       <span class="token keyword">return</span> number <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span>  <span class="token operator">?</span>             <span class="token constant">MAXIMUM_CAPACITY</span>  <span class="token operator">:</span> <span class="token punctuation">(</span>number <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">highestOneBit</span><span class="token punctuation">(</span><span class="token punctuation">(</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析2：key的值为null的处理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">（分析<span class="token number">2</span>）<span class="token comment">// 2.1 若key == null，则将该键-值存放到数组table中的第1个位置，即table[0]</span>        <span class="token comment">// （本质：key = Null时，hash值 = 0，故存放到table[0]中）</span>        <span class="token comment">// 该位置永远只有1个value，新传进来的value会覆盖旧的value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * 源码分析：putForNullKey(value) */</span><span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span><span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 遍历以table[0]为首的链表，寻找是否存在key==null 对应的键值对</span>    <span class="token comment">// 1. 若有：则用新value 替换 旧value；同时返回旧的value值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>              e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>              e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>          <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>      modCount<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment">// 2 .若无key==null的键，那么调用addEntry（），将空键 &amp; 对应的值封装到Entry中，并放到table[0]中</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 注：</span>    <span class="token comment">// a. addEntry（）的第1个参数 = hash值 = 传入0</span>    <span class="token comment">// b. 即 说明：当key = null时，也有hash值 = 0，所以HashMap的key 可为null</span>    <span class="token comment">// c. 对比HashTable，由于HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null。但是HashMap不会报错，是可以key为null的。</span>    <span class="token comment">// d. 此处只需知道是将 key-value 添加到HashMap中即可，关于addEntry（）的源码分析将等到下面再详细说明，</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析3：计算出key的hash值并得出下标</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">（分析<span class="token number">3</span>） <span class="token comment">// 2.2 若 key ≠ null，则计算存放数组 table 中的位置（下标、索引）</span>        <span class="token comment">// a. 根据键值key计算hash值</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// b. 根据hash值 最终获得 key对应存放的数组Table中位置</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/**     * 源码分析1：hash(key)     * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）     * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算     * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算     */</span>     <span class="token comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>     <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>        h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>      <span class="token comment">// 1. 取hashCode值： h = key.hashCode() </span>      <span class="token comment">// 2. 高位参与低位的运算：h ^ (h >>> 16)  </span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">int</span> h<span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span>            <span class="token comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span>            <span class="token comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span>     <span class="token punctuation">&#125;</span>   <span class="token comment">/**     * 函数源码分析2：indexFor(hash, table.length)     * JDK 1.8中实际上无该函数，但原理相同，即具备类似作用的函数     */</span>      <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算下标的方法是(table.length - 1) &amp; hash，算法直接舍弃了二进制hash值在table.length以上的位，因为那些位都代表table.length的2的n次方倍数。计算的结果就是Node将要放入table的下标，解决 “哈希码与数组大小范围不匹配” 的问题。这也是为什么一开始容量要变成大于给定值的2的幂次方。</p><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210204143847164.png" alt="2"></p><p><strong>所有处理的根本目的，都是为了提高 存储<code>key-value</code>的数组下标位置 的随机性 &amp; 分布均匀性，尽量避免出现hash值冲突</strong>。即：对于不同<code>key</code>，存储的数组下标位置要尽可能不一样</p><p>分析4：判断key对应的值是否已存在，存在旧值，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 函数使用原型 */</span><span class="token comment">// 2. 判断该key对应的值是否已存在（通过遍历 以该数组元素为头结点的链表 逐个判断）</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Object</span> k<span class="token punctuation">;</span>    <span class="token comment">// 2.1 若该key已存在（即 key-value已存在 ），则用 新value 替换 旧value</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//JDK 1.7是空函数</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span> <span class="token comment">//并返回旧的value</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 2.2 若 该key不存在，则将“key-value”添加到table中</span><span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分析5：若该key不存在，则将“key-value”添加到table中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">（分析<span class="token number">5</span>）<span class="token comment">// 3.2 若 该key不存在，则将“key-value”添加到table中</span>        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 源码分析：addEntry(hash, key, value, i)     * 作用：添加键值对（Entry ）到 HashMap中     */</span>      <span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 参数4 = 插入数组table的索引位置 = 数组下标</span>                    <span class="token comment">// 1. 插入前，先判断容量是否足够</span>          <span class="token comment">// 1.1 若不足够，则进行扩容（2倍）、重新计算Hash值、重新计算存储数组下标</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a. 扩容2倍  --> 分析1</span>            hash <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// b. 重新计算该Key对应的hash值</span>            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// c. 重新计算该Key对应的hash值的存储数组下标位置</span>     <span class="token punctuation">&#125;</span>      <span class="token comment">// 1.2 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中--> 分析2</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token comment">/**   * 分析1：resize(2 * table.length)   * 作用：当容量不足时（容量 > 阈值），则扩容（扩到2倍）   */</span>    <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 1. 保存旧数组（old table） </span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>      <span class="token comment">// 2. 保存旧容量（old capacity ），即数组长度</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>     <span class="token comment">// 3. 若旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出    </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>        <span class="token comment">// 4. 根据新容量（2倍容量）新建1个数组，即新table  </span>    <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 5. 将旧数组上的数据（键值对）转移到新table中，从而完成扩容 ->>分析1.1 </span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 6. 新数组table引用到HashMap的table属性上</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>      <span class="token comment">// 7. 重新设置阈值  </span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>  <span class="token comment">/**   * 分析1.1：transfer(newTable);    * 作用：将旧数组上的数据（键值对）转移到新table中，从而完成扩容   * 过程：按旧链表的正序遍历链表、在新链表的头部依次插入   */</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 1. src引用了旧数组</span>      <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> src <span class="token operator">=</span> table<span class="token punctuation">;</span>       <span class="token comment">// 2. 获取新数组的大小 = 获取新容量大小                 </span>      <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token comment">// 3. 通过遍历 旧数组，将旧数组上的数据（键值对）转移到新数组中</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> src<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">// 3.1 取得旧数组的每个元素  </span>          <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> src<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                     <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>              <span class="token comment">// 3.2 释放旧数组的对象引用（for循环后，旧数组不再引用任何对象）</span>              src<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>               <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// 3.3 遍历 以该数组元素为首 的链表</span>                  <span class="token comment">// 注：转移链表时，因是单链表，故要保存下1个结点，否则转移后链表会断开</span>                  <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                  <span class="token comment">// 3.4 重新计算每个元素的存储位置</span>                 <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 3.5 将元素放在数组上：采用单链表的头插入方式 = 在链表头上存放数据 = 将数组位置的原有数据放在后1个指针、将需放入的数据放到数组位置中</span>                 <span class="token comment">// 即 扩容后，可能出现逆序：按旧链表的正序遍历链表、在新链表的头部依次插入</span>                 e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                  newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                   <span class="token comment">// 3.6 访问下1个Entry链上的元素，如此不断循环，直到遍历完该链表上的所有节点</span>                 e <span class="token operator">=</span> next<span class="token punctuation">;</span>                          <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 如此不断循环，直到遍历完数组上的所有数据元素</span>         <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> <span class="token comment">/**   * 分析2：createEntry(hash, key, value, bucketIndex);     * 作用： 若容量足够，则创建1个新的数组元素（Entry） 并放入到数组中   */</span>  <span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 1. 把table中该位置原来的Entry保存  </span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 2. 在table中该位置新建一个Entry：将原头结点位置（数组上）的键值对 放入到（链表）后1个节点中、将需插入的键值对 放入到头结点中（数组上）-> 从而形成链表</span>    <span class="token comment">// 即 在插入元素时，是在链表头插入的，table中的每个位置永远只保存最新插入的Entry，旧的Entry则放入到链表中（即 解决Hash冲突）</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 3. 哈希表的键值对数量计数增加</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>在扩容resize（）过程中，在将旧数组上的数据 转移到 新数组上时，转移操作 &#x3D; 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况。即扩容前 &#x3D; 1-&gt;2-&gt;3，扩容后 &#x3D; 3-&gt;2-&gt;1</p></li><li><p>此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则<strong>容易出现环形链表</strong>，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即 死锁的状态 &#x3D; 线程不安全。</p></li><li><p>扩容为原来的两倍，大小仍然是2的幂。求新的下标的时候，length-1的二进制就相当于在高位加上了一个1，依然可以充分散列，提高下标的随机性和均匀性。并且，length-1的二进制就相当于在高位加上了一个1，所以求出来的新下标位置，要么就是原来的下标，要么就相当于原来的下标位置 + 扩容之前的数组长度。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**   * 函数原型   * 作用：根据键key，向HashMap获取对应的值   */</span>    map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>； <span class="token comment">/**   * 源码分析   */</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token comment">// 1. 当key == null时，则到 以哈希表数组中的第1个元素（即table[0]）为头结点的链表去寻找对应 key == null的键</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">></span> 分析<span class="token number">1</span>    <span class="token comment">// 2. 当key ≠ null时，去获得对应值 -->分析2</span>    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span> <span class="token operator">==</span> entry <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>   <span class="token comment">/**   * 分析1：getForNullKey()   * 作用：当key == null时，则到 以哈希表数组中的第1个元素（即table[0]）为头结点的链表去寻找对应 key == null的键   */</span> <span class="token keyword">private</span> <span class="token class-name">V</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 遍历以table[0]为头结点的链表，寻找 key==null 对应的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token comment">// 从table[0]中取key==null的value值 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>              <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token comment">/**   * 分析2：getEntry(key)   * 作用：当key ≠ null时，去获得对应值   */</span>  <span class="token keyword">final</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token comment">// 1. 根据key值，通过hash（）计算出对应的hash值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 2. 根据hash值计算出对应的数组下标</span>    <span class="token comment">// 3. 遍历 以该数组下标的数组元素为头结点的链表所有节点，寻找该key对应的值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token class-name">Object</span> k<span class="token punctuation">;</span>          <span class="token comment">// 若 hash值 &amp; key 相等，则证明该Entry = 我们要的键值对</span>        <span class="token comment">// 通过equals（）判断key是否相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>              <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              <span class="token keyword">return</span> e<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 函数使用原型  */</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/**   * 源码分析：主要是HashMap的构造函数 = 4个   * 仅贴出关于HashMap构造函数的源码   */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>    <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 省略上节阐述的参数</span>      <span class="token comment">/**     * 构造函数1：默认构造函数（无参）     * 加载因子 &amp; 容量 = 默认 = 0.75、16     */</span>    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 构造函数2：指定“容量大小”的构造函数     * 加载因子 = 默认 = 0.75 、容量 = 指定大小     */</span>    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 实际上是调用指定“容量大小”和“加载因子”的构造函数</span>        <span class="token comment">// 只是在传入的加载因子参数 = 默认加载因子</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 构造函数3：指定“容量大小”和“加载因子”的构造函数     * 加载因子 &amp; 容量 = 自己指定     */</span>    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 指定初始容量必须非负，否则报错  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                             initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY，哪怕传入的 > 最大容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">;</span>        <span class="token comment">// 填充比必须为正  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token class-name">Float</span><span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                             loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 设置 加载因子</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        <span class="token comment">// 设置 扩容阈值</span>        <span class="token comment">// 注：此处不是真正的阈值，仅仅只是将传入的容量大小转化为：>传入容量大小的最小的2的幂，该阈值后面会重新计算</span>        <span class="token comment">// 下面会详细讲解 ->> 分析1</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 构造函数4：包含“子Map”的构造函数     * 即 构造出来的HashMap包含传入Map的映射关系     * 加载因子 &amp; 容量 = 默认     */</span>    <span class="token keyword">public</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">></span></span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 设置容量大小 &amp; 加载因子 = 默认</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token constant">DEFAULT_LOAD_FACTOR</span><span class="token punctuation">;</span>         <span class="token comment">// 将传入的子Map中的全部元素逐个添加到HashMap中</span>        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>   <span class="token comment">/**     * 分析1：tableSizeFor(initialCapacity)     * 作用：将传入的容量大小转化为：>传入容量大小的最小的2的幂     * 与JDK 1.7对比：类似于JDK 1.7 中 inflateTable()里的 roundUpToPowerOf2(toSize)     */</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">int</span> n <span class="token operator">=</span> cap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>     n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>     n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">;</span>     n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">;</span>     n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">8</span><span class="token punctuation">;</span>     n <span class="token operator">|=</span> n <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>n <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">:</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">/**     * 分析1：hash(key)     * 作用：计算传入数据的哈希码（哈希值、Hash值）     * 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）     * JDK 1.7 做了9次扰动处理 = 4次位运算 + 5次异或运算     * JDK 1.8 简化了扰动函数 = 只做了2次扰动 = 1次位运算 + 1次异或运算     */</span>      <span class="token comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span>      <span class="token comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span>      <span class="token comment">// 1. 取hashCode值： h = key.hashCode() </span>      <span class="token comment">// 2. 高位参与低位的运算：h ^ (h >>> 16)  </span>      <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">int</span> h<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span>            <span class="token comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span>            <span class="token comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span>     <span class="token punctuation">&#125;</span>   <span class="token comment">/**     * 计算存储位置的函数分析：indexFor(hash, table.length)     * 注：该函数仅存在于JDK 1.7 ，JDK 1.8中实际上无该函数（直接用1条语句判断写出），但原理相同     * 为了方便讲解，故提前到此讲解     */</span>     <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1），最终得到存储在数组table的位置（即数组下标、索引）</span>     <span class="token punctuation">&#125;</span><span class="token comment">/** * 参数：hash值，key键值，value具体值，是false，当存在相同的key时也可以更改value值 */</span><span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token comment">//数组容量 </span>        <span class="token comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建</span>    <span class="token comment">// 所以，初始化哈希表的时机 = 第1次调用put函数时，即调用resize() 初始化创建  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Object</span> p<span class="token punctuation">;</span><span class="token comment">//当前元素</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//下标</span>        <span class="token comment">// 2. 插入时，需判断是否存在Hash冲突：</span>    <span class="token comment">// 若不存在（即当前table[i] == null），则直接在该数组位置新建节点，插入完毕</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 否则，代表存在Hash冲突，即当前存储位置已存在节点，则依次往下判断</span>        <span class="token class-name">Object</span> e<span class="token punctuation">;</span><span class="token comment">//暂存结点</span>        <span class="token class-name">Object</span> k<span class="token punctuation">;</span><span class="token comment">//临时的key</span>        <span class="token comment">// a. 当前位置数组元素的key与需插入的key相同</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment">//b. key不同，并且插入的数据结构为红黑树</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>TreeNode</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>TreeNode</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//->>分析3</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//c. key不同，并且插入的数据结构为链表</span>            <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//记录链表节点数</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//迭代到最后一个元素，都没找到相同的key，直接加在链表最后面（尾插法）</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//插入节点后，若链表节点数>数阈值，则将链表转换为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span><span class="token comment">//找到了相同的key，跳出循环，执行后面的以新换旧</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment">//更新p指向下一个节点，继续遍历</span>                <span class="token operator">++</span>binCount<span class="token punctuation">;</span><span class="token comment">//节点数+1</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//找到了相同的key，以新换旧，返回旧值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">V</span> oldValue <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterNodeAccess</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 替换旧值时会调用的方法（默认实现为空）</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//记录散列表被修改的次数（以新换旧不算）</span>    <span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">;</span>    <span class="token comment">//如果达到了扩容阈值，需要扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>threshold<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//->>分析4</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token comment">/**     * 分析4：resize（）     * 该函数有2种使用情况：1.初始化哈希表 2.当前数组容量过小，需扩容     */</span>   <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span> <span class="token comment">// 扩容前的数组</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 扩容前的数组的容量 = 长度</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span><span class="token comment">// 扩容前的数组的阈值</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//扩容之后的数组容量，新的扩容阈值</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 针对情况2：若扩容前的数组容量超过最大值，则不再扩充</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> <span class="token constant">MAXIMUM_CAPACITY</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 针对情况2：若容量没有超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span>                 oldCap <span class="token operator">>=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 通过右移扩充2倍</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 针对情况1：只调用了构造方法给了初始容量（有参构造），初始容量为0，扩容阈值为默认容量16</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold </span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token comment">// 针对情况1：调用了无参构造方法，初始容量为0</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>               <span class="token comment">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_LOAD_FACTOR</span> <span class="token operator">*</span> <span class="token constant">DEFAULT_INITIAL_CAPACITY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算新的扩容阈值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> <span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token constant">MAXIMUM_CAPACITY</span> <span class="token operator">?</span>                  <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token comment">//创建出新的容量的数组  </span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span><span class="token comment">//当前数组元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//方便JVM GC时回收内存</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token comment">//只有单个元素的链表，没有发生过哈希碰撞</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment">//红黑树</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//链表（新下标要么不变，要么是原下标+旧容量）</span>                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                     <span class="token comment">//低位链表：扩容之后的数组下标和原来的下标一样</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token comment">//高位链表：扩容之后的数组下标 = 原数组下标 + 扩容之前的数组容量</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> next<span class="token punctuation">;</span>                                        <span class="token comment">//依次遍历每个结点，加到相应链表的尾部，最后找出低位和高位链表的头尾指针</span>                    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment">// 最妙：判断是高位链表还是低位链表，</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">// 原索引 + oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                       <span class="token comment">//把完整的链表放进数组</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                                        <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**   * 函数原型   * 作用：根据键key，向HashMap获取对应的值   */</span>    map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>； <span class="token comment">/**   * 源码分析   */</span>    <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>    <span class="token comment">// 1. 计算需获取数据的hash值</span>    <span class="token comment">// 2. 通过getNode（）获取所查询的数据 ->>分析1</span>    <span class="token comment">// 3. 获取后，判断数据是否为空</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/**   * 分析1：getNode(hash(key), key))   */</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>    <span class="token comment">// 1. 计算存放在数组table中的位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 4. 通过该函数，依次在数组、红黑树、链表中查找（通过equals（）判断）</span>        <span class="token comment">// a. 先在数组中找，若存在，则直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment">// b. 若数组中没有，则到红黑树中寻找</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// c. 若红黑树中也没有，则通过遍历，到链表中寻找</span>            <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210302163232577.png" alt="image-20210302163232577"></p><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210302165212134.png" alt="image-20210302165212134"></p><ol><li>当前结点的父亲叔叔都是红色，父亲叔叔变成黑色，祖父变成红色，指针指向祖父(12)。</li><li>当前结点(12)父亲是红色，叔叔是黑色，并且是左右双红。以当前结点父亲作为根节点进行左旋，指针指向父亲结点(5)。然后就会变成左左双红的情况。</li></ol><p><img src="/2023/03/06/di-er-ge-wen-zhang/image-20210302165240887.png" alt="image-20210302165240887"></p><ol start="3"><li><p>当前结点(5)父亲是红色，叔叔是黑色，并且是左左双红。父亲变成黑色，祖父变成红色，以当前结点祖父作为根节点进行右旋，指针指向父亲结点。</p><p>另外还有两种情况：</p><ol><li>当前结点父亲时红色，叔叔是黑色，并且是右右双红。父亲变黑色，祖父变成红色，以当前结点祖父作为根节点进行左旋，指针指向父亲结点。</li><li>当前结点父亲是红色，叔叔是黑色，并且是右左双红。以当前结点父亲作为根节点进行右旋，指针指向父亲结点。然后就会变成右右双红的情况。</li></ol></li></ol><h4 id="线程安全的HashMap"><a href="#线程安全的HashMap" class="headerlink" title="线程安全的HashMap"></a>线程安全的HashMap</h4><ol><li>换成hashtable：采用的是synchronized方法上加锁，使用阻塞同步，效率低。</li><li>使用Collections类的synchronizedMap方法包装一下。方法如下：public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)  返回由指定映射支持的同步（线程安全的）映射。也是采用synchronized方法上加锁，使用阻塞同步，效率低。</li><li>使用ConcurrentHashMap，采用锁分段技术，减小锁的粒度，效率高。ConcurrentHashMap中是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。</li></ol><h4 id="HashMap面试："><a href="#HashMap面试：" class="headerlink" title="HashMap面试："></a>HashMap面试：</h4><h5 id="1-谈一下HashMap的特性？"><a href="#1-谈一下HashMap的特性？" class="headerlink" title="1.谈一下HashMap的特性？"></a><strong>1.谈一下HashMap的特性？</strong></h5><ul><li><p>HashMap存储键值对实现快速存取，允许为null。key值不可重复，若key值重复则覆盖。</p></li><li><p>非同步，线程不安全的。</p><ul><li>JDK1.7，在扩容的过程中，在将旧数组上的数据转移到新数组上时，遍历旧数组进行头插法到新的数组上去，容易出现<strong>链表逆序的情况</strong>，在多线程下，就容易发生<strong>环形链表</strong>。</li><li>JDK1.8，扩容的过程中转移数据操作是按旧链表的正序遍历链表、在新链表的尾部依次插入，所以不会出现链表 <strong>逆序、倒置</strong>的情况，故不容易出现环形链表的情况。但还是线程不安全，因为无加同步锁保护</li></ul></li><li><p>底层是hash表，不保证有序(比如插入的顺序)。</p></li></ul><h5 id="2-谈一下hashMap中put是如何实现的？"><a href="#2-谈一下hashMap中put是如何实现的？" class="headerlink" title="2.谈一下hashMap中put是如何实现的？"></a><strong>2.谈一下hashMap中put是如何实现的？</strong></h5><p>1.计算关于key的hashcode值（Key.hashCode的高16位和低16位做异或运算）</p><p>2.然后判断散列表是否为空，为空时，调用resize()初始化散列表</p><p>3.不为空在判断是否发生碰撞，没有就直接添加元素到散列表中去</p><p>4.如果发生了碰撞(hashCode值相同)，进行三种判断</p><p>  4.1.若和该数组元素相同或者equals，则替换旧值并返回旧值</p><p>  4.2.如果是红黑树结构，就调用树的插入方法</p><p>  4.3.链表结构，循环遍历直到链表中某个节点为空，尾插法进行插入，插入之后判断链表个数是否到达变成红黑树的阈值8；如果找到了相同的key，替换旧值并返回旧值</p><p>5.如果存在的键值对数量大于阈值，则resize进行扩容</p><h5 id="3-谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？"><a href="#3-谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？" class="headerlink" title="3.谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？"></a><strong>3.谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？</strong></h5><p>调用场景：</p><p>1.初始化数组table</p><p>2.当数组table的size达到阈值时即++size &gt; load factor * capacity 时，也是在putVal函数中</p><p>实现过程：</p><p>1.通过判断旧数组的容量是否大于0来判断数组是否初始化过</p><ul><li><p>否：进行初始化</p><ul><li>判断是否调用无参构造器，<ul><li>是：使用默认的大小和阈值</li><li>否：使用构造函数中初始化的容量，当然这个容量是经过tableSizefor计算后的2的次幂数</li></ul></li></ul></li><li><p>是，进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中</p><ul><li>判断是红黑树还是单链表，单链表就按照原来的hash值放到新的数组中，下标要么和原来一样，要么是加上原来的容量</li></ul></li></ul><h5 id="4-谈一下hashMap中get是如何实现的？"><a href="#4-谈一下hashMap中get是如何实现的？" class="headerlink" title="4.谈一下hashMap中get是如何实现的？"></a><strong>4.谈一下hashMap中get是如何实现的？</strong></h5><pre><code>对key的hashCode进行hash，与运算计算下标获取下标位置，如果在数组的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。</code></pre><h5 id="5-谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？"><a href="#5-谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？" class="headerlink" title="5.谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？"></a><strong>5.谈一下HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</strong></h5><pre><code>对key的hashCode做hash操作，在jdk1.7：4次位运算和5次异或运算；在jdk1.8：与高16位做异或运算还有平方取中法，除留余数法，伪随机数法。</code></pre><h5 id="6-为什么不直接将key作为哈希值而是与高16位做异或运算？"><a href="#6-为什么不直接将key作为哈希值而是与高16位做异或运算？" class="headerlink" title="6.为什么不直接将key作为哈希值而是与高16位做异或运算？"></a><strong>6.为什么不直接将key作为哈希值而是与高16位做异或运算？</strong></h5><p>因为数组位置的确定用的是与运算，仅仅和低位有关，设计者将key的哈希值与高16位做异或运算，使得在做&amp;运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了<strong>随机性和均匀性</strong>，减少了哈希碰撞的次数。</p><h5 id="7-为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"><a href="#7-为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？" class="headerlink" title="7.为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"></a><strong>7.为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</strong></h5><p>1.为了数据的均匀分布，减少哈希碰撞。因为确定数组位置是用的按位与运算，提高了效率。若数据不是2的次幂，有些下标永远取不到，浪费数组空间。</p><p>2.输入数据若不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字</p><h5 id="8-谈一下当两个对象的hashCode相等时会怎么样？"><a href="#8-谈一下当两个对象的hashCode相等时会怎么样？" class="headerlink" title="8.谈一下当两个对象的hashCode相等时会怎么样？"></a><strong>8.谈一下当两个对象的hashCode相等时会怎么样？</strong></h5><p>会产生哈希碰撞，然后去寻找有没有相同的key值，若key值相同则替换旧值，不然就链接到链表后面，链表长度超过阈值8就转为红黑树存储。</p><h5 id="9-如果两个键的hashcode相同，你如何获取值对象？"><a href="#9-如果两个键的hashcode相同，你如何获取值对象？" class="headerlink" title="9.如果两个键的hashcode相同，你如何获取值对象？"></a><strong>9.如果两个键的hashcode相同，你如何获取值对象？</strong></h5><p>HashCode相同，通过equals比较内容获取值对象</p><h5 id="10-”如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#10-”如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="10.”如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a><strong>10.”如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong></h5><p>超过阈值会进行扩容操作，概括的讲就是扩容后的数组大小是原数组的2倍，将原来的元素重新计算下标放入到新的散列表中去。</p><h5 id="11-HashMap和HashTable的异同"><a href="#11-HashMap和HashTable的异同" class="headerlink" title="11.HashMap和HashTable的异同"></a><strong>11.HashMap和HashTable的异同</strong></h5><p>相同点：都是存储key-value键值对的</p><p>不同点：</p><ul><li>HashMap允许Key-value为null，hashTable不允许；</li><li>hashMap没有考虑同步，是线程不安全的。hashTable是线程安全的，给方法加上了synchronized锁;</li><li>HashMap继承于AbstractMap类，hashTable继承与Dictionary类。</li><li>迭代器(Iterator)。HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException。</li><li>容量的<strong>初始值和扩容方式</strong>都不一样：HashMap默认的容量大小是16；增加容量时，每次将容量变为”原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为”原始容量x2 + 1”；</li><li>添加key-value时的<strong>hash值算法</strong>不同：HashMap添加元素时，是使用自定义的哈希算法。Hashtable没有自定义哈希算法，而直接采用的key的hashCode()。</li></ul><h5 id="12-请解释一下HashMap的参数loadFactor，它的作用是什么？"><a href="#12-请解释一下HashMap的参数loadFactor，它的作用是什么？" class="headerlink" title="12.请解释一下HashMap的参数loadFactor，它的作用是什么？"></a><strong>12.请解释一下HashMap的参数loadFactor，它的作用是什么？</strong></h5><p>loadFactor表示HashMap的加载因子，影响hash操作到同一个数组位置的概率。默认loadFactor等于0.75，当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，需要扩容，在HashMap的构造器中可以定制loadFactor。为0.75的话，元素出现在hash槽的概率遵循平均参数为0.5的泊松分布。对空间和时间上成本的一种折衷考量。</p><h5 id="13-传统hashMap的缺点-为什么引入红黑树？"><a href="#13-传统hashMap的缺点-为什么引入红黑树？" class="headerlink" title="13.传统hashMap的缺点(为什么引入红黑树？)"></a><strong>13.传统hashMap的缺点(为什么引入红黑树？)</strong></h5><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，当 HashMap 中有大量的元素存入的时候，会导致某个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，遍历的时间复杂度就是 O(n)。针对这种情况，JDK 1.8 中引入了 红黑树，是一个平衡查找树，查询时间和树的高度有关，查找时间复杂度为 O(logn)。AVL树是更加严格的平衡，旋转的次数要更多。防止导致产生严重的哈希碰撞，预防Dos攻击。</p><h5 id="14-平时在使用HashMap时一般使用什么类型的元素作为Key？"><a href="#14-平时在使用HashMap时一般使用什么类型的元素作为Key？" class="headerlink" title="14. 平时在使用HashMap时一般使用什么类型的元素作为Key？"></a><strong>14. 平时在使用HashMap时一般使用什么类型的元素作为Key？</strong></h5><p>选择Integer，String这种final修饰的不可变的类型，像对String的一切操作都是新建一个String对象，对新的对象进行拼接分割等，这些类已经很规范的覆写了hashCode()以及equals()方法。作为不可变类天生是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇测试</title>
      <link href="/2023/03/06/di-yi-pian-ce-shi/"/>
      <url>/2023/03/06/di-yi-pian-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章节"><a href="#第一章节" class="headerlink" title="第一章节"></a>第一章节</h1><p>这是第一章节<br>来张图片：![天空 (6)](.&#x2F;第一篇测试&#x2F;天空 (6).jpg)</p><h2 id="第二章节"><a href="#第二章节" class="headerlink" title="第二章节"></a>第二章节</h2><p>第二章节二章节二章节二章节</p><table><thead><tr><th align="center">时代</th><th align="center">说的</th><th align="center">撒打算多发</th></tr></thead><tbody><tr><td align="center">阿道夫</td><td align="center">大师开光</td><td align="center">啊大噶的管理</td></tr><tr><td align="center">434</td><td align="center">—————-</td><td align="center">答复</td></tr><tr><td align="center">23</td><td align="center">挨打发的56654</td><td align="center">安店123425t</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/04/hello-world/"/>
      <url>/2023/03/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
